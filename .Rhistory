usethis::use_mit_license(“Emily Potts”)
library(devtools)
library(roxygen2)
library(usethis)
library(pkgdown)
usethis::use_mit_license(“Emily Potts”)
usethis::use_mit_license('Emily Potts')
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
.rs.restartR()
devtools::load_all()  # Loads package functions without installing
devtools::install()
library(hiperglm)
hiper_glm(matrix(1:6, nrow = 3), c(1, 0, 1))
# Set seed for reproducibility
set.seed(123)
# Generate 100 observations
n <- 100
# Continuous predictor (e.g., age)
age <- rnorm(n, mean = 50, sd = 10)
# Categorical predictor (e.g., treatment group)
treatment <- sample(c(0, 1), n, replace = TRUE)
# Design matrix (with intercept)
design <- model.matrix(~ age + treatment)
# Generate outcome using a logistic model
beta <- c(-2, 0.05, 1)  # Intercept, age effect, treatment effect
logit_prob <- design %*% beta
prob <- exp(logit_prob) / (1 + exp(logit_prob))  # Convert to probability
outcome <- rbinom(n, size = 1, prob = prob)  # Generate binary outcome
# Test your function
hiper_glm(design, outcome)
install.packages("testthat")
library(testthat)
usethis::use_testthat()
usethis::use_test("are_all_close")
1e-6
usethis::use_test("test-hiper_glm")
usethis::use_test("mle-finder")
devtools::test()
usethis::use_test("gaussian_grad")
devtools::test()
devtools::test("gaussian_grad")
testthat::test_file("tests/testthat/test-gaussian_grad.R")
testthat::test_file("tests/testthat/test-gaussian_grad.R")
testthat::test_file("tests/testthat/test-mle-finder.R")
testthat::test_file("tests/testthat/test-mle-finder.R")
testthat::test_file("tests/testthat/test-gaussian_grad.R")
devtools::test()
devtools::test()
devtools::test()
testthat::test_file("tests/testthat/test-mle-finder.R")
source("tests/testthat/test-mle-finder.R", echo = TRUE)
rlang::last_trace()
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
outcome <- data$outcome
design <- data$design
linalg_out <- hiper_glm(design, outcome, model = "linear", optimizer = "pseudo-inverse")
optim_out <- hiper_glm(design, outcome, model = "linear", optimizer = "BFGS")
cat("\nLinear algebra output:\n")
print(coef(linalg_out))
cat("\nOptimization output:\n")
print(coef(optim_out))
devtools::install()  # Reinstalls the package
?hiper_glm
devtools::load_all()
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
are_all_close <- function(v, w, abs_tol = 1e-6, rel_tol = 1e-6) {
abs_diff <- abs(v - w)
are_all_within_atol <- all(abs_diff < abs_tol)
are_all_within_rtol <- all(abs_diff < rel_tol * pmax(abs(v), abs(w)))
return(are_all_within_atol && are_all_within_rtol)
}
simulate_data <- function(
n_obs, n_pred, model = "linear", intercept = NULL,
coef_true = NULL, design = NULL, seed = NULL, signal_to_noise = 0.1
) {
if (!is.null(seed)) {
set.seed(seed)
}
if (is.null(coef_true)) {
coef_true <- rnorm(n_pred, sd = 1 / sqrt(n_pred))
}
if (is.null(design)) {
design <- matrix(rnorm(n_obs * n_pred), nrow = n_obs, ncol = n_pred)
}
if (!is.null(intercept)) {
if (!is.numeric(intercept)) {
stop("The intercept argument must be numeric.")
}
coef_true <- c(intercept, coef_true)
design <- cbind(rep(1, n_obs), design)
}
expected_mean <- as.vector(design %*% coef_true)
noise_magnitude <- sqrt(var(expected_mean) / signal_to_noise^2)
noise <- noise_magnitude * rnorm(n_obs)
outcome <- expected_mean + noise
return(list(design = design, outcome = outcome, coef_true = coef_true))
}
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
outcome <- data$outcome
design <- data$design
linalg_out <- hiper_glm(design, outcome, model = "linear", optimizer = "pseudo-inverse")
library(hiperglm)
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
outcome <- data$outcome
design <- data$design
linalg_out <- hiper_glm(design, outcome, model = "linear", optimizer = "pseudo-inverse")
remove.packages("hiperglm")
devtools::clean_dll()  # Clean compiled objects
devtools::document()   # Regenerate documentation
library(hiperglm)
devtools::load_all()
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
outcome <- data$outcome
design <- data$design
linalg_out <- hiper_glm(design, outcome, model = "linear", optimizer = "pseudo-inverse")
optim_out <- hiper_glm(design, outcome, model = "linear", optimizer = "BFGS")
cat("\nLinear algebra output:\n")
print(coef(linalg_out))
cat("\nOptimization output:\n")
print(coef(optim_out))
devtools::load_all()
n_obs <- 32
n_pred <- 4
data <- simulate_data(n_obs, n_pred, model = "linear", seed = 1918)
outcome <- data$outcome
design <- data$design
linalg_out <- hiper_glm(design, outcome, model = "linear", optimizer = "pseudo-inverse")
optim_out <- hiper_glm(design, outcome, model = "linear", optimizer = "BFGS")
cat("\nLinear algebra output:\n")
print(coef(linalg_out))
cat("\nOptimization output:\n")
print(coef(optim_out))
devtools::install()
devtools::check()
